<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Shader 1</title>
	
	<style>
		* { padding: 0; margin: 0; }
		#container { position: fixed; top: 0; bottom: 0; left: 0; right: 0; }
	</style>

	<script src="../three.js"></script>
</head>
<body>
	<div id="container"></div>
	
	<script id="vs" type="x-shader/x-vertex">
		uniform float time;
		
		attribute float size;
		attribute vec3 color;

		varying vec3 vColor;
		varying float vSize;

		void main() {
			vColor = color;
			vSize = size;

			vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
			gl_PointSize = size * ( 200.0 / -mvPosition.z );
			gl_Position = projectionMatrix * mvPosition;
		}
	</script>

	<script id="fs" type="x-shader/x-fragment">
		uniform float time;
		uniform sampler2D texture;

		varying vec3 vColor;
		varying float vSize;

		vec2 transformUV(vec2 uv, float a[9]) {
		    
		    // Convert UV to vec3 to apply matrices
		    vec3 u = vec3(uv, 1.0);
		    
		    // Array consists of the following
		    // 0 translate.x
		    // 1 translate.y
		    // 2 skew.x
		    // 3 skew.y
		    // 4 rotate
		    // 5 scale.x
		    // 6 scale.y
		    // 7 origin.x
		    // 8 origin.y
		    
		    // Origin before matrix
		    mat3 mo1 = mat3(
		                    1, 0, -a[7],
		                    0, 1, -a[8],
		                    0, 0, 1);
		    
		    // Origin after matrix
		    mat3 mo2 = mat3(
		                    1, 0, a[7],
		                    0, 1, a[8],
		                    0, 0, 1);
		    
		    // Translation matrix
		    mat3 mt = mat3(
		                   1, 0, -a[0],
		                   0, 1, -a[1],
		                   0, 0, 1);
		    
		    // Skew matrix
		    mat3 mh = mat3(
		                   1, a[2], 0,
		                   a[3], 1, 0,
		                   0, 0, 1);
		    
		    // Rotation matrix
		    mat3 mr = mat3(
		                   cos(a[4]), sin(a[4]), 0,
		                   -sin(a[4]), cos(a[4]), 0,
		                   0, 0, 1);
		    
		    // Scale matrix
		    mat3 ms = mat3(
		                   1.0 / a[5], 0, 0,
		                   0, 1.0 / a[6], 0,
		                   0, 0, 1);
		    
		    // apply translation
		   	u = u * mt;
		    
		    // apply skew
		   	u = u * mh;
		    
		    // apply rotation relative to origin
		    u = u * mo1;
		    u = u * mr;
		    u = u * mo2;
		    
		    // apply scale relative to origin
		    u = u * mo1;
		    u = u * ms;
		    u = u * mo2;
		    
		    // Return vec2 of new UVs
		    return u.xy;
		}

		vec2 rotate(vec2 uv) {
		    float values[9];
		    values[0] = 0.0; //x
		    values[1] = 0.0; //y
		    values[2] = 0.0; //skewX
		    values[3] = 0.0; //skewY
		    values[4] = -time * vSize * 0.1; //rotation
		    values[5] = (sin(time * vSize * 0.025)/2.0 + 0.6); //scaleX
		    values[6] = 1.0; //scaleY
		    values[7] = 0.5; //originX
		    values[8] = 0.5; //originY
		    return transformUV(uv, values);
		}

		void main (void) {
			vec2 uv = vec2(gl_PointCoord.x, 1.0 - gl_PointCoord.y);
			uv = rotate(uv);

			vec4 texel = texture2D( texture, uv );
			gl_FragColor = texel * vec4(vColor, texel.a);
		}
	</script>

	<script>
		
	var container, camera, renderer, scene, mesh, uniforms;
	var W = window.innerWidth;
	var H = window.innerHeight;
	var particles = 32000;

	init();
	animate();

	function init() {

		container = document.getElementById( 'container' );

		camera = new THREE.PerspectiveCamera( 45, W / H, 1, 2000 );
		camera.position.z = 300;

		scene = new THREE.Scene();		

		var geometry = new THREE.BufferGeometry();

		var points = new Float32Array( particles * 3 );
		var colors = new Float32Array( particles * 3 );
		var sizes = new Float32Array( particles );

		var color = new THREE.Color();

		for( var i = 0, i3 = 0; i < particles; i++, i3 += 3 ) {
			points[ i3 + 0 ] = Math.random() * 200 - 100;
			points[ i3 + 1 ] = Math.random() * 200 - 100;
			points[ i3 + 2 ] = Math.random() * 200 - 100;

			color.setHSL( i / particles, 1.0, 0.5 );
			colors[ i3 + 0 ] = color.r;
			colors[ i3 + 1 ] = color.g;
			colors[ i3 + 2 ] = color.b;

			sizes[ i ] = Math.abs( Math.random() * 128 - 64 );
			// sizes[ i ] = 20;
		}
		
		// var vertices = new Float32Array([
		// 	-1.5, -1.0,  1.0,
		// 	 0.0, -0.5,  1.0,
		// 	 1.0, -1.0,  1.0,
		// 	 0.0,  1.0,  0.0,
		// 	 1.0,  1.0,  1.0,
		// 	 0.0,  0.5,  1.0, 
		// 	-1.0,  1.0,  1.5, 
		// 	]);

		// var colors = new Float32Array([
		// 	255.0, 0.0, 0.0,
		// 	0.0, 255.0, 0.0,
		// 	0.0, 0.0, 255.0,
		// 	255.0, 255.0, 255.0,
		// 	255.0, 0.0, 0.0,
		// 	0.0, 255.0, 0.0,
		// 	0.0, 0.0, 255.0,
		// 	]);

		// var sizes = new Float32Array([
		// 	3, 1, 4, 3, 2, 4, 2
		// 	]);

		geometry.addAttribute( 'position', new THREE.BufferAttribute( points, 3 ) );
		geometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );
		geometry.addAttribute( 'size', new THREE.BufferAttribute( sizes, 1 ) );

		uniforms = { 
			time: { type: 'f', value: 1.0 },
			texture: { type: "t", value: new THREE.TextureLoader().load( "../images/original/1-2.png" ) }
		};

		var shaderMaterial = new THREE.ShaderMaterial({
			uniforms: uniforms,
			vertexShader: document.getElementById( 'vs' ).textContent,
			fragmentShader: document.getElementById( 'fs' ).textContent,
			blending: THREE.AdditiveBlending,
			transparent: true,
			depthTest: false,
		});
		
		mesh =  new THREE.Points( geometry, shaderMaterial );

		scene.add( mesh );

		renderer = new THREE.WebGLRenderer();
		renderer.setPixelRatio( window.devicePixelRatio );
		renderer.setClearColor( 0x141823 );

		container.appendChild( renderer.domElement );

		onWindowResize();

		window.addEventListener( 'resize', onWindowResize, false );
	}

	function onWindowResize( event ) {

		W = window.innerWidth;
		H = window.innerHeight;
		
		camera.aspect = W / H;
		camera.updateProjectionMatrix();

		renderer.setSize( W, H );
	}

	function animate() {

		requestAnimationFrame( animate );
		render();
	}

	function render() {

		mesh.rotation.y += 0.005;
		mesh.rotation.x -= 0.005;
		mesh.rotation.z -= 0.005;
		uniforms.time.value += 0.05;
		renderer.render( scene, camera );
	}

	</script>
</body>
</html>